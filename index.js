const express = require("express");
const fs = require("fs");
const path = require("path");
const HmCrypto = require("hm-crypto-nodejs");

const readPem = filename => {
  return fs.readFileSync(path.resolve(__dirname, filename)).toString("ascii");
};

const digestType = "RSA-SHA256";

const STATUS_CODES = {
  RS_ERROR_UNKNOWN: "RS_ERROR_UNKNOWN",
  RS_ERROR_INVALID_PARTNER: "RS_ERROR_INVALID_PARTNER",
  RS_ERROR_INVALID_TOKEN: "RS_ERROR_INVALID_TOKEN",
  RS_ERROR_INVALID_GAME: "RS_ERROR_INVALID_GAME",
  RS_ERROR_WRONG_CURRENCY: "RS_ERROR_WRONG_CURRENCY",
  RS_ERROR_NOT_ENOUGH_MONEY: "RS_ERROR_NOT_ENOUGH_MONEY",
  RS_ERROR_USER_DISABLED: "RS_ERROR_USER_DISABLED",
  RS_ERROR_TOKEN_EXPIRED: "RS_ERROR_TOKEN_EXPIRED",
  RS_ERROR_DUPLICATE_TRANSACTION: "RS_ERROR_DUPLICATE_TRANSACTION",
  RS_ERROR_TRANSACTION_DOES_NOT_EXIST: "RS_ERROR_TRANSACTION_DOES_NOT_EXIST",
  RS_ERROR_TRANSACTION_ROLLED_BACK: "RS_ERROR_TRANSACTION_ROLLED_BACK"
};

/**
 * @typedef {Object} CallbackResponse
 * @property {string} user Unique User ID in the Operator’s system. In case of DEMO gameplay, this parameter may be omitted.
 * @property {string} status Response status. Can be obtained via STATUS_CODES
 * @property {string} currency ISO 4217 currency code. Following enum contains all currencies supported by our system. Existing of currency in this list doesn't mean that all providers support native game play with it. Please contact us to know which provider supports which currencies.
 * @property {number} balance We use integers to represent the amount of money. To convert real float value to integer we multiply it by 100000. Example: $3.56 must be represented as 356000
 *
 * @typedef {Object} BalanceRequest
 * @property {string} token The game session token that was passed within /game/url
 * @property {string} request_uuid Standard 16-byte UUID. This id can be seen as network layer action. An id of an action that is generated for each our call to Operator. Used to sync Hub88 and Operator sides for debugging purposes. Operator has to respond with the same request_uuid as the one that was received in request. Handled internally.
 * @property {number} game_id Unique game ID in Hub88 system. Can be obtained from /game/list endpoint.
 *
 * @typedef {Object} WinRequest
 * @property {string} transaction_uuid Unique transaction identifier. An id of business logic action (transaction) that needs to be stored on both sides. Operator has to respond idempotently on each transaction_uuid. Action with same transaction_uuid shouldn't be processed more than once.
 * @property {string} token The game session token that was passed within /game/url
 * @property {string} supplier_user The name of the user in Provider’s system (in case Operator needs to find user in Provder’s back office or report problem with the user). If value is NULL, the Operator can search for their own user_id.
 * @property {string} round Game round id. Used to relate all bets and wins in one round. All transactions related to the same round will have the same value in this field. It's not unique through whole system. Uniqueness depends on provider’s RGS logic, however, game + user + round in all cases yields very high uniqueness.
 * @property {string} reference_transaction_uuid Unique identifier of the transaction that this transaction is referencing. In case of rollback, this field will contain transaction_uuid of the transaction which needs to be rolled back. In case of win, there will be transaction_uuid of the bet to which this win is related.
 * @property {boolean} is_free Flag which shows that transaction was generated by a promotional tool (FreeSpins, etc). Usually, these transactions are credited to bonus wallets (if available).lated.
 * @property {string} request_uuid Standard 16-byte UUID. This id can be seen as network layer action. An id of an action that is generated for each our call to Operator. Used to sync Hub88 and Operator sides for debugging purposes. Operator has to respond with the same request_uuid as the one that was received in request. Handled internally.
 * @property {number} game_id Unique game ID in Hub88 system. Can be obtained from /game/list endpoint.
 * @property {string} currency ISO 4217 currency code. Following enum contains all currencies supported by our system. Existing of currency in this list doesn't mean that all providers support native game play with it. Please contact us to know which provider supports which currencies.
 * @property {string} bet Field for metadata related to transaction, such as type of bet, value, time, etc. Differs from game to game. Not relevant for transaction processing procedure but could be useful for statistics or activity backtracking.
 * @property {number} amount We use integers to represent the amount of money. To convert real float value to integer we multiply it by 100000. Example: $3.56 must be represented as 356000
 *
 * @typedef {Object} RollbackRequest
 * @property {string} transaction_uuid Unique transaction identifier. An id of business logic action (transaction) that needs to be stored on both sides. Operator has to respond idempotently on each transaction_uuid. Action with same transaction_uuid shouldn't be processed more than once.
 * @property {string} token The game session token that was passed within /game/url
 * @property {string} round Game round id. Used to relate all bets and wins in one round. All transactions related to the same round will have the same value in this field. It's not unique through whole system. Uniqueness depends on provider’s RGS logic, however, game + user + round in all cases yields very high uniqueness.
 * @property {string} reference_transaction_uuid Unique identifier of the transaction that this transaction is referencing. In case of rollback, this field will contain transaction_uuid of the transaction which needs to be rolled back. In case of win, there will be transaction_uuid of the bet to which this win is related.
 * @property {string} request_uuid Standard 16-byte UUID. This id can be seen as network layer action. An id of an action that is generated for each our call to Operator. Used to sync Hub88 and Operator sides for debugging purposes. Operator has to respond with the same request_uuid as the one that was received in request. Handled internally.
 * @property {number} game_id Unique game ID in Hub88 system. Can be obtained from /game/list endpoint.
 *
 * @typedef {Object} BetRequest
 * @property {string} transaction_uuid Unique transaction identifier. An id of business logic action (transaction) that needs to be stored on both sides. Operator has to respond idempotently on each transaction_uuid. Action with same transaction_uuid shouldn't be processed more than once.
 * @property {string} token The game session token that was passed within /game/url
 * @property {string} supplier_user The name of the user in Provider’s system (in case Operator needs to find user in Provder’s back office or report problem with the user). If value is NULL, the Operator can search for their own user_id.
 * @property {string} round Game round id. Used to relate all bets and wins in one round. All transactions related to the same round will have the same value in this field. It's not unique through whole system. Uniqueness depends on provider’s RGS logic, however, game + user + round in all cases yields very high uniqueness.
 * @property {boolean} is_free Flag which shows that transaction was generated by a promotional tool (FreeSpins, etc). Usually, these transactions are credited to bonus wallets (if available).lated.
 * @property {string} request_uuid Standard 16-byte UUID. This id can be seen as network layer action. An id of an action that is generated for each our call to Operator. Used to sync Hub88 and Operator sides for debugging purposes. Operator has to respond with the same request_uuid as the one that was received in request. Handled internally.
 * @property {number} game_id Unique game ID in Hub88 system. Can be obtained from /game/list endpoint.
 * @property {string} currency ISO 4217 currency code. Following enum contains all currencies supported by our system. Existing of currency in this list doesn't mean that all providers support native game play with it. Please contact us to know which provider supports which currencies.
 * @property {string} bet Field for metadata related to transaction, such as type of bet, value, time, etc. Differs from game to game. Not relevant for transaction processing procedure but could be useful for statistics or activity backtracking.
 * @property {number} amount We use integers to represent the amount of money. To convert real float value to integer we multiply it by 100000. Example: $3.56 must be represented as 356000
 *
 *
 * Callback for balance
 *
 * @callback balanceCallback
 * @param {BalanceRequest} request
 * @return {CallbackResponse}
 *
 * Callback for transaction win
 *
 * @callback winCallback
 * @param {WinRequest} request
 * @return {CallbackResponse}
 *
 * Callback for transaction rollback
 *
 * @callback rollbackCallback
 * @param {RollbackRequest} request
 * @return {CallbackResponse}
 *
 * Callback for transaction bet
 *
 * @callback betCallback
 * @param {BetRequest} request
 * @return {CallbackResponse}
 */

const createRoute = requiredFields => cb => (req, res) => {
  const isValidRequest =
    req.body && requiredFields.every(field => req.body[field] !== undefined);

  if (!isValidRequest) {
    res.send({
      status: "RS_ERROR_WRONG_SYNTAX"
    });
    return;
  }

  const result = cb(req.body);

  const isValidResult =
    result.status ||
    (result.user && result.currency && result.balance !== undefined);

  if (!isValidResult) {
    throw Error("Method should return `user`, `currency`, `balance` fields");
  }

  const { user, currency, balance } = result;

  res.send({
    status: result.status || "RS_OK",
    ...{ user, currency, balance },
    request_uuid: req.body.request_uuid
  });
};

const createBalanceRoute = createRoute(["request_uuid", "token", "game_id"]);

const createWinRoute = createRoute([
  "transaction_uuid",
  "token",
  "supplier_user",
  "round",
  "request_uuid",
  "reference_transaction_uuid",
  "is_free",
  "game_id",
  "currency",
  "bet",
  "amount"
]);

const createRollbackRoute = createRoute([
  "transaction_uuid",
  "token",
  "round",
  "request_uuid",
  "reference_transaction_uuid",
  "game_id"
]);

const createBetRoute = createRoute([
  "transaction_uuid",
  "token",
  "supplier_user",
  "round",
  "request_uuid",
  "is_free",
  "game_id",
  "currency",
  "bet",
  "amount"
]);

const validateSignature = hmCrypto => (req, res, next) => {
  const isValid = hmCrypto.isValid(
    JSON.stringify(req.body),
    req.get("X-Hub88-Signature")
  );

  if (isValid) {
    return next();
  }

  res.send({
    status: "RS_ERROR_INVALID_SIGNATURE",
    request_uuid: req.body.request_uuid
  });
};

const defaultParams = {
  port: 3000,
  publicKey: "priv/demo_pub.pem",
  privateKey: "priv/demo_priv.pem"
};

class Ngiw {
  constructor(params = defaultParams) {
    this.params = params;

    const publicKeyPem = readPem(params.publicKey);
    const privateKeyPem = readPem(params.privateKey);

    const hmCrypto = HmCrypto(digestType, privateKeyPem, publicKeyPem);

    this.app = express();

    this.app.use(express.json());
    this.app.use(validateSignature(hmCrypto));
  }

  /**
   * Called when player's balance is needed. Operator is expected to return player's current balance. Game id is provided to help Operator with player's activity statistics.
   * @param {balanceCallback} cb
   */
  balance(cb) {
    this._balanceCallback = cb;

    return this;
  }

  /**
   * Called when the User wins (credit). Operator is expected to increase player's balance by amount and return new balance. reference_transaction_uuid show to which bet this win is related.
   * Each win has transaction_uuid which is unique identifier of this transaction. Before any altering of User's balance, Operator has to check that win wasn't processed before.
   * Retry Policy: In case of network fail (HTTP 502, timeout, nxdomain, etc.) we will retry 3 times with 1 sec of timeout. The rest of retry logic is left to provider’s RGS: the retries may continue indefinitely or the bet may be rolled back, and the money returned back to user.
   * @param {winCallback} cb
   */
  win(cb) {
    this._winCallback = cb;

    return this;
  }

  /**
   * Called when there is need to roll back the effect of the referenced transaction. Operator is expected to find referenced transaction, roll back its effects and return the player's new balance.
   * @param {rollbackCallback} cb
   */
  rollback(cb) {
    this._rollbackCallback = cb;

    return this;
  }

  /**
   * Called when the User places a bet (debit). Operator is expected to decrease player's balance by amount and return new balance.
   * Each bet has transaction_uuid which is unique identifier of this transaction. Before altering of User's balance, Operator has to check that bet wasn't processed before. There might be
   * Retry Policy: In case of network fail (HTTP 502, timeout, nxdomain, etc.), we will retry 3 times with 1 sec of timeout. If we do not receive 200 HTTP status, this transaction will be counted as failed and rollback will be generated (to ensure that failed bet hadn’t affected User’s balance). This rollback will be retried 500 times (or less if we get logical response) with exponential back off.
   * @param {betCallback} cb
   */
  bet(cb) {
    this._betCallback = cb;

    return this;
  }

  start() {
    if (!this._balanceCallback) {
      throw Error("Balance callback should be implemented");
    }

    if (!this._winCallback) {
      throw Error("Win callback should be implemented");
    }

    if (!this._rollbackCallback) {
      throw Error("Rollback callback should be implemented");
    }

    if (!this._betCallback) {
      throw Error("Bet callback should be implemented");
    }

    const balanceRoute = createBalanceRoute(this._balanceCallback);

    const winRoute = createWinRoute(this._winCallback);

    const rollbackRoute = createRollbackRoute(this._rollbackCallback);

    const betRoute = createRollbackRoute(this._betCallback);

    this.app.post("/user/balance", balanceRoute);

    this.app.post("/transaction/win", winRoute);

    this.app.post("/transaction/rollback", rollbackRoute);

    this.app.post("/transaction/bet", betRoute);

    this.app.listen(this.params.port, () =>
      console.log(`NGIW listening on port ${this.params.port}!`)
    );

    return this;
  }
}

Ngiw.STATUS_CODES = STATUS_CODES;
Ngiw._createBalanceRoute = createBalanceRoute;
Ngiw._createWinRoute = createWinRoute;
Ngiw._createRollbackRoute = createRollbackRoute;
Ngiw._createBetRoute = createBetRoute;
Ngiw._validateSignature = validateSignature;

module.exports = Ngiw;
